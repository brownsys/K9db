load("@rules_java//java:defs.bzl", "java_binary")

genrule(
    name = "DataDataFlowGraphLibrary",
    srcs = [
        "//pelton/dataflow:generator_h",
        "DataFlowGraphLibraryConfig.java",
    ],
    outs = ["DataFlowGraphLibrary.java"],
    cmd = """
  # A side effect of running javacpp.jar is that it compiles
  # DataFlowGraphLibraryConfig.java and other input files, and generates a
  # .class file for each. It will do so in the same directory as the input file,
  # which is write-protected when running within bazel.
  # We copy the input file to a read/write directory and process it there.

  # Remember where we should have been executing from within the bazel fs.
  EXEC_PATH=$$(pwd)

  # Get the location of javacpp.jar, libgenerator.so, and include path.
  JAVACPP_JAR=$$(pwd)/$(location @maven//:org_bytedeco_javacpp)
  INCLUDE_PATH=$$(pwd)

  # Create a clean tmp directory and copy input files to it.
  TMP_DIR="/tmp/__DataFlowGraphLibrary_tmp"
  rm -rf $${TMP_DIR}
  PCKG_DIR=$${TMP_DIR}/com/brownsys/pelton/planner/nativelib/
  mkdir -p $${PCKG_DIR}
  cp $(location DataFlowGraphLibraryConfig.java) $${PCKG_DIR}

  # Execute javacpp.jar in tmp directory
  cd $${TMP_DIR}
  java -jar "$${JAVACPP_JAR}"                    \
      -Dplatform.includepath=$${INCLUDE_PATH}    \
      com/brownsys/pelton/planner/nativelib/DataFlowGraphLibraryConfig.java

  # Move outputs to proper directory and remove tmp directory.
  cd $${EXEC_PATH}
  mv $${PCKG_DIR}/DataFlowGraphLibrary.java $@
  rm -rf $${TMP_DIR}
""",
    tools = ["@maven//:org_bytedeco_javacpp"],
    visibility = ["//pelton/planner/calcite:__subpackages__"],
)

genrule(
    name = "JniDataDataFlowGraphLibrary_so",
    srcs = [
        ":DataDataFlowGraphLibrary",
        "//pelton/dataflow:generator_so",
        "//pelton/dataflow:generator_h",
        "DataFlowGraphLibraryConfig.java",
    ],
    outs = [
        "libjniDataFlowGraphLibrary.so",
    ],
    cmd = """
  # Similar to above, we need to process things in a tmp directory.
  # Remember where we should have been executing from within the bazel fs.
  EXEC_PATH=$$(pwd)
  READ_PATH=$${EXEC_PATH}
  while [ $$(basename $${READ_PATH}) != "sandbox" ]
  do
    READ_PATH=$$(dirname $${READ_PATH})
  done
  READ_PATH=$$(dirname $${READ_PATH})/execroot/pelton

  # Get the location of javacpp.jar, libgenerator.so, and include path.
  JAVACPP_JAR=$$(pwd)/$(location @maven//:org_bytedeco_javacpp)
  LINK_PATH=$${READ_PATH}/$$(dirname $(location //pelton/dataflow:generator_so))
  INCLUDE_PATH=$$(pwd)

  # Create a clean tmp directory and copy input files to it.
  TMP_DIR="/tmp/__JniDataDataFlowGraphLibrary_so_tmp"
  rm -rf $${TMP_DIR}
  PCKG_DIR=$${TMP_DIR}/com/brownsys/pelton/planner/nativelib/
  mkdir -p $${PCKG_DIR}
  cp $(location DataFlowGraphLibraryConfig.java) $${PCKG_DIR}
  cp $(location :DataDataFlowGraphLibrary) $${PCKG_DIR}

  # Execute javacpp.jar in tmp directory
  cd $${TMP_DIR}
  java -jar "$${JAVACPP_JAR}"                 \
      -nodelete                               \
      -Dplatform.includepath=$${INCLUDE_PATH} \
      -Dplatform.linkpath=$${LINK_PATH}       \
      com/brownsys/pelton/planner/nativelib/DataFlowGraphLibrary.java

  # Move outputs to proper directory and remove tmp directory.
  cd $${EXEC_PATH}
  mv $${PCKG_DIR}/linux-x86_64/libjniDataFlowGraphLibrary.so $@
  # rm -rf $${TMP_DIR}
""",
    tools = ["@maven//:org_bytedeco_javacpp"],
)

java_binary(
    name = "Main",
    srcs = [
        "DataFlowGraphLibraryConfig.java",
        "Main.java",
        ":DataDataFlowGraphLibrary",
    ],
    data = [
        ":JniDataDataFlowGraphLibrary_so",
        "//pelton/dataflow:generator_so",
    ],
    jvm_flags = ["-Djava.library.path=$$( dirname \"$${BASH_SOURCE[0]}\" )"],
    main_class = "com.brownsys.pelton.planner.nativelib.Main",
    visibility = ["//pelton/planner:__subpackages__"],
    deps = [
        "@maven//:org_bytedeco_javacpp",
    ],
)
